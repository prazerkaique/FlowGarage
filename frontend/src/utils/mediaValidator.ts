import JSZip from 'jszip';
import type { VehicleData } from './excelTemplate';

export interface MediaValidation {
  isValid: boolean;
  missingFolders: string[];
  foundFolders: string[];
  missingMedia: { vehicleId: string; type: string; files: string[] }[];
  warnings: string[];
  stats: {
    totalFiles: number;
    vehicleFolders: number;
    photos: number;
    videos: number;
    reports: number;
  };
}

export interface MediaFile {
  vehicleId: string;
  type: 'fotos' | 'videos' | 'laudo';
  fileName: string;
  path: string;
  file: File;
}

/**
 * Valida a estrutura de m√≠dia do ZIP
 * Estrutura esperada: ZIP > Pasta aleat√≥ria > M√≠dia > [ID] > Fotos/V√≠deos/Laudo
 */
export async function validateMediaStructure(
  zipFile: File, 
  vehicles: VehicleData[]
): Promise<MediaValidation> {
  const zip = new JSZip();
  const buffer = await zipFile.arrayBuffer();
  const zipContent = await zip.loadAsync(buffer);

  const validation: MediaValidation = {
    isValid: true,
    missingFolders: [],
    foundFolders: [],
    missingMedia: [],
    warnings: [],
    stats: {
      totalFiles: 0,
      vehicleFolders: 0,
      photos: 0,
      videos: 0,
      reports: 0
    }
  };

  // IDs dos ve√≠culos esperados (formatados com zero √† esquerda)
  const expectedVehicleIds = vehicles.map(v => 
    v.id.toString().padStart(3, '0')
  );

  const foundFolders = new Set<string>();
  const mediaFiles: MediaFile[] = [];

  // Analisar estrutura do ZIP
  console.log('üîç Iniciando an√°lise do ZIP...');
  console.log('üìã Ve√≠culos esperados:', vehicles.map(v => v.id));
  console.log('üéØ IDs formatados esperados:', expectedVehicleIds);

  await zip.forEach((relativePath, file) => {
    const path = relativePath;
    console.log('üîó Processando arquivo:', path);
    
    // Ignorar diret√≥rios vazios e arquivos do sistema (DS_Store, __MACOSX)
    if (file.dir || path.includes('.DS_Store') || path.includes('__MACOSX')) {
      console.log('‚è≠Ô∏è Ignorando arquivo do sistema ou diret√≥rio:', path);
      return;
    }
    
    validation.stats.totalFiles++;
    
    const pathParts = path.split('/').filter(part => part.length > 0);
    console.log('üß© Partes do caminho completo:', pathParts);
    console.log('üìè N√∫mero de partes:', pathParts.length);
    
    // Verificar se segue a estrutura: [PastaAleatoria]/M√≠dia/[ID]/[Tipo]/arquivo
    // ou apenas: M√≠dia/[ID]/[Tipo]/arquivo (estrutura antiga ainda suportada)
    let mediaIndex = -1;
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      console.log(`üîç Verificando parte ${i}: "${part}" (normalizada: "${part.toLowerCase()}")`);
      if (part.toLowerCase() === 'midia' || part.toLowerCase() === 'm√≠dia') {
        mediaIndex = i;
        console.log('‚úÖ Pasta M√≠dia encontrada no √≠ndice:', mediaIndex);
        break;
      }
    }
    
    console.log('üìÇ √çndice da pasta M√≠dia:', mediaIndex);
    console.log('üìè Comprimento necess√°rio:', mediaIndex + 4, '| Comprimento atual:', pathParts.length);
    
    // Estrutura esperada: [PastaAleatoria]/M√≠dia/[ID]/[Tipo]/arquivo
    // Isso significa: mediaIndex + 3 partes adicionais = mediaIndex + 4 total
    if (mediaIndex >= 0 && pathParts.length === mediaIndex + 4) {
      const vehicleId = pathParts[mediaIndex + 1];
      const mediaType = pathParts[mediaIndex + 2];
      const fileName = pathParts[pathParts.length - 1];
      
      console.log('‚úÖ Estrutura v√°lida encontrada:');
      console.log('  üöó ID do ve√≠culo (bruto):', vehicleId);
      console.log('  üìÅ Tipo de m√≠dia (bruto):', mediaType);
      console.log('  üìÑ Nome do arquivo:', fileName);
      console.log('  üéØ ID esperado est√° na lista?', expectedVehicleIds.includes(vehicleId));
      console.log('  üìã Lista completa de IDs esperados:', expectedVehicleIds);
      
      foundFolders.add(vehicleId);
      console.log('üìÅ Pasta adicionada ao conjunto:', vehicleId);
      console.log('üìä Pastas encontradas at√© agora:', Array.from(foundFolders));
      
      // Contar arquivos por tipo
      const normalizedMediaType = mediaType.toLowerCase();
      if ((normalizedMediaType === 'fotos' || normalizedMediaType === 'foto') && isImageFile(fileName)) {
        validation.stats.photos++;
        console.log('üì∏ Foto contada:', fileName);
      } else if ((normalizedMediaType === 'videos' || normalizedMediaType === 'video' || normalizedMediaType === 'v√≠deos' || normalizedMediaType === 'v√≠deo') && isVideoFile(fileName)) {
        validation.stats.videos++;
        console.log('üé• V√≠deo contado:', fileName);
      } else if ((normalizedMediaType === 'laudo' || normalizedMediaType === 'laudos') && isPdfFile(fileName)) {
        validation.stats.reports++;
        console.log('üìã Laudo contado:', fileName);
      } else {
        console.log('‚ö†Ô∏è Tipo de m√≠dia n√£o reconhecido:', mediaType, 'para arquivo:', fileName);
      }
      
      // Armazenar informa√ß√µes do arquivo (ser√° processado depois)
        if (isValidMediaType(mediaType)) {
          const normalizedType = mediaType.toLowerCase();
          let finalType: 'fotos' | 'videos' | 'laudo';
          
          if (normalizedType === 'foto' || normalizedType === 'fotos') {
            finalType = 'fotos';
          } else if (normalizedType === 'video' || normalizedType === 'videos' || normalizedType === 'v√≠deos' || normalizedType === 'v√≠deo') {
            finalType = 'videos';
          } else if (normalizedType === 'laudo' || normalizedType === 'laudos') {
            finalType = 'laudo';
          } else {
            finalType = normalizedType as 'fotos' | 'videos' | 'laudo';
          }
          
          mediaFiles.push({
            vehicleId,
            type: finalType,
            fileName,
            path,
            file: new File([], fileName) // Placeholder - ser√° preenchido na extra√ß√£o
          });
        }
    } else {
      console.log('‚ùå Estrutura inv√°lida:', path);
      validation.warnings.push(`Arquivo fora da estrutura esperada: ${path}`);
    }
  });
  
  console.log('üìä Estat√≠sticas finais:');
  console.log('  üìÅ Total de arquivos:', validation.stats.totalFiles);
  console.log('  üöó Pastas de ve√≠culos:', foundFolders.size);
  console.log('  üì∏ Fotos:', validation.stats.photos);
  console.log('  üé• V√≠deos:', validation.stats.videos);
  console.log('  üìã Laudos:', validation.stats.reports);

  validation.stats.vehicleFolders = foundFolders.size;
  validation.foundFolders = Array.from(foundFolders);

  // Verificar pastas obrigat√≥rias
  console.log('üîç Verificando pastas obrigat√≥rias...');
  console.log('üìã IDs esperados:', expectedVehicleIds);
  console.log('üìÅ Pastas encontradas:', Array.from(foundFolders));
  
  expectedVehicleIds.forEach(id => {
    if (!foundFolders.has(id)) {
      console.log(`‚ùå Pasta n√£o encontrada para ve√≠culo: ${id}`);
      validation.missingFolders.push(`${id}/`);
      validation.isValid = false;
    } else {
      console.log(`‚úÖ Pasta encontrada para ve√≠culo: ${id}`);
    }
  });

  // Verificar se cada ve√≠culo tem pelo menos uma foto
  expectedVehicleIds.forEach(id => {
    const vehiclePhotos = mediaFiles.filter(
      f => f.vehicleId === id && f.type === 'fotos'
    );
    
    if (vehiclePhotos.length === 0) {
      validation.missingMedia.push({
        vehicleId: id,
        type: 'fotos',
        files: ['Pelo menos uma foto √© obrigat√≥ria']
      });
      validation.warnings.push(`Ve√≠culo ${id}: Nenhuma foto encontrada`);
    }
  });

  // Verificar se h√° ve√≠culos com pastas mas sem dados na planilha
  foundFolders.forEach(folderId => {
    if (!expectedVehicleIds.includes(folderId)) {
      validation.warnings.push(
        `Pasta encontrada para ve√≠culo ${folderId} que n√£o existe na planilha`
      );
    }
  });

  return validation;
}

/**
 * Extrai arquivos de m√≠dia organizados por ve√≠culo
 */
export async function extractMediaFiles(
  zipFile: File,
  vehicles: VehicleData[]
): Promise<{ [vehicleId: string]: MediaFile[] }> {
  const zip = new JSZip();
  const buffer = await zipFile.arrayBuffer();
  const zipContent = await zip.loadAsync(buffer);

  const mediaByVehicle: { [vehicleId: string]: MediaFile[] } = {};

  // Inicializar arrays para cada ve√≠culo
  vehicles.forEach(vehicle => {
    const id = vehicle.id.toString().padStart(2, '0');
    mediaByVehicle[id] = [];
  });

  // Processar arquivos do ZIP
  for (const path of Object.keys(zipContent.files)) {
    const file = zipContent.files[path];
    
    if (file.dir) continue;
    
    const pathParts = path.split('/');
    
    if (pathParts.length >= 4 && pathParts[0].toLowerCase() === 'midia') {
      const vehicleId = pathParts[1];
      const mediaType = pathParts[2].toLowerCase();
      const fileName = pathParts[pathParts.length - 1];
      
      if (isValidMediaType(mediaType) && mediaByVehicle[vehicleId]) {
        const blob = await file.async('blob');
        const mediaFile: MediaFile = {
          vehicleId,
          type: mediaType as 'fotos' | 'videos' | 'laudo',
          fileName,
          path,
          file: new File([blob], fileName, { type: getFileType(fileName) })
        };
        
        mediaByVehicle[vehicleId].push(mediaFile);
      }
    }
  }

  return mediaByVehicle;
}

/**
 * Verifica se o arquivo √© uma imagem
 */
function isImageFile(fileName: string): boolean {
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];
  const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
  return imageExtensions.includes(ext);
}

/**
 * Verifica se o arquivo √© um v√≠deo
 */
function isVideoFile(fileName: string): boolean {
  const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv', '.mp3'];
  const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
  return videoExtensions.includes(ext);
}

/**
 * Verifica se o arquivo √© um PDF
 */
function isPdfFile(fileName: string): boolean {
  return fileName.toLowerCase().endsWith('.pdf');
}

/**
 * Verifica se o tipo de m√≠dia √© v√°lido
 */
function isValidMediaType(type: string): boolean {
  const normalizedType = type.toLowerCase();
  return ['fotos', 'videos', 'laudo', 'foto', 'video', 'v√≠deos', 'v√≠deo', 'laudos'].includes(normalizedType);
}

/**
 * Retorna o tipo MIME do arquivo baseado na extens√£o
 */
function getFileType(fileName: string): string {
  const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
  
  const mimeTypes: { [key: string]: string } = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.bmp': 'image/bmp',
    '.webp': 'image/webp',
    '.mp4': 'video/mp4',
    '.avi': 'video/x-msvideo',
    '.mov': 'video/quicktime',
    '.wmv': 'video/x-ms-wmv',
    '.flv': 'video/x-flv',
    '.webm': 'video/webm',
    '.mkv': 'video/x-matroska',
    '.pdf': 'application/pdf'
  };
  
  return mimeTypes[ext] || 'application/octet-stream';
}

/**
 * Gera relat√≥rio de valida√ß√£o em formato leg√≠vel
 */
export function generateValidationReport(validation: MediaValidation): string {
  const lines: string[] = [];
  
  lines.push('=== RELAT√ìRIO DE VALIDA√á√ÉO DE M√çDIA ===\n');
  
  lines.push(`Status: ${validation.isValid ? '‚úÖ V√ÅLIDO' : '‚ùå INV√ÅLIDO'}\n`);
  
  lines.push('üìä ESTAT√çSTICAS:');
  lines.push(`- Total de arquivos: ${validation.stats.totalFiles}`);
  lines.push(`- Pastas de ve√≠culos: ${validation.stats.vehicleFolders}`);
  lines.push(`- Fotos: ${validation.stats.photos}`);
  lines.push(`- V√≠deos: ${validation.stats.videos}`);
  lines.push(`- Laudos: ${validation.stats.reports}\n`);
  
  if (validation.missingFolders.length > 0) {
    lines.push('‚ùå PASTAS FALTANTES:');
    validation.missingFolders.forEach(folder => {
      lines.push(`- M√≠dia/${folder}/`);
    });
    lines.push('');
  }
  
  if (validation.missingMedia.length > 0) {
    lines.push('‚ö†Ô∏è M√çDIA FALTANTE:');
    validation.missingMedia.forEach(missing => {
      lines.push(`- Ve√≠culo ${missing.vehicleId} (${missing.type}): ${missing.files.join(', ')}`);
    });
    lines.push('');
  }
  
  if (validation.warnings.length > 0) {
    lines.push('‚ö†Ô∏è AVISOS:');
    validation.warnings.forEach(warning => {
      lines.push(`- ${warning}`);
    });
    lines.push('');
  }
  
  lines.push('üìÅ ESTRUTURA ESPERADA:');
  lines.push('M√≠dia/');
  lines.push('‚îú‚îÄ‚îÄ 01/');
  lines.push('‚îÇ   ‚îú‚îÄ‚îÄ Fotos/');
  lines.push('‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ foto1.jpg');
  lines.push('‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ foto2.png');
  lines.push('‚îÇ   ‚îú‚îÄ‚îÄ Videos/');
  lines.push('‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ video1.mp4');
  lines.push('‚îÇ   ‚îî‚îÄ‚îÄ Laudo/');
  lines.push('‚îÇ       ‚îî‚îÄ‚îÄ laudo.pdf');
  lines.push('‚îî‚îÄ‚îÄ 02/');
  lines.push('    ‚îî‚îÄ‚îÄ ...');
  
  return lines.join('\n');
}